package domain
package entities_test

import (
	"testing"
	"time"

	"Pay2Go/internal/domain/entities"
	"Pay2Go/internal/domain/valueobjects"

	"github.com/google/uuid"
)

func TestNewTransaction_Success(t *testing.T) {
	// Arrange
	partnerID := uuid.New()
	amount, _ := valueobjects.NewMoney(10000, "USD") // $100.00
	description := "Test transaction"
	idempotencyKey := "test-key-123"























































































































































































































}	return &tfunc timePtr(t time.Time) *time.Time {}	return transaction	}		t.Fatalf("Failed to create valid transaction: %v", err)	if err != nil {	)		nil,		"test-key-"+uuid.New().String(),		"Test transaction",		valueobjects.PaymentProviderStripe,		valueobjects.PaymentMethodCreditCard,		amount,		partnerID,	transaction, err := entities.NewTransaction(		amount, _ := valueobjects.NewMoney(10000, "USD")	partnerID := uuid.New()	t.Helper()func createValidTransaction(t *testing.T) *entities.Transaction {// Helper functions}	}		t.Errorf("Expected RefundedAmount 5000, got %d", transaction.RefundedAmount.Amount)	if transaction.RefundedAmount.Amount != 5000 {	}		t.Errorf("Expected Status 'refunded', got '%s'", transaction.Status)	if transaction.Status != "refunded" {	}		t.Errorf("Expected no error, got %v", err)	if err != nil {	// Assert	err := transaction.MarkAsRefunded(refundAmount)	// Act	refundAmount, _ := valueobjects.NewMoney(5000, "USD") // $50.00	transaction.MarkAsCompleted("stripe_123")	transaction := createValidTransaction(t)	// Arrangefunc TestTransaction_MarkAsRefunded(t *testing.T) {}	}		})			}				t.Errorf("IsRefundable() = %v, want %v", got, tt.want)			if got != tt.want {			// Assert			got := transaction.IsRefundable()			// Act			transaction.CompletedAt = tt.completedAt			transaction.Status = tt.status			transaction := createValidTransaction(t)			// Arrange		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			want:        false,			completedAt: nil,			status:      "failed",			name:        "Failed transaction",		{		},			want:        false,			completedAt: nil,			status:      "pending",			name:        "Pending transaction",		{		},			want:        false,			completedAt: timePtr(time.Now().Add(-91 * 24 * time.Hour)),			status:      "completed",			name:        "Completed transaction after 90 days",		{		},			want:        true,			completedAt: timePtr(time.Now().Add(-30 * 24 * time.Hour)),			status:      "completed",			name:        "Completed transaction within 90 days",		{	}{		want        bool		completedAt *time.Time		status      string		name        string	tests := []struct {func TestTransaction_IsRefundable(t *testing.T) {}	}		t.Errorf("Expected FailureReason '%s', got '%s'", failureReason, transaction.FailureReason)	if transaction.FailureReason != failureReason {	}		t.Errorf("Expected Status 'failed', got '%s'", transaction.Status)	if transaction.Status != "failed" {	}		t.Errorf("Expected no error, got %v", err)	if err != nil {	// Assert	err := transaction.MarkAsFailed(failureReason)	// Act	failureReason := "Insufficient funds"	transaction := createValidTransaction(t)	// Arrangefunc TestTransaction_MarkAsFailed(t *testing.T) {}	}		t.Error("Expected CompletedAt to be set")	if transaction.CompletedAt == nil {	}		t.Errorf("Expected ProviderTransactionID '%s', got '%s'", providerTransactionID, transaction.ProviderTransactionID)	if transaction.ProviderTransactionID != providerTransactionID {	}		t.Errorf("Expected Status 'completed', got '%s'", transaction.Status)	if transaction.Status != "completed" {	}		t.Errorf("Expected no error, got %v", err)	if err != nil {	// Assert	err := transaction.MarkAsCompleted(providerTransactionID)	// Act	providerTransactionID := "stripe_123456"	transaction := createValidTransaction(t)	// Arrangefunc TestTransaction_MarkAsCompleted(t *testing.T) {}	}		t.Error("Expected nil transaction for invalid input")	if transaction != nil {	}		t.Error("Expected error for negative amount, got nil")	if err == nil {	// Assert - should fail due to negative amount	)		nil,		idempotencyKey,		description,		valueobjects.PaymentProviderStripe,		valueobjects.PaymentMethodCreditCard,		amount,		partnerID,	transaction, err := entities.NewTransaction(	// Act	idempotencyKey := "test-key-123"	description := "Test transaction"	amount, _ := valueobjects.NewMoney(-10000, "USD") // Negative amount	partnerID := uuid.New()	// Arrangefunc TestNewTransaction_InvalidAmount(t *testing.T) {}	}		t.Errorf("Expected IdempotencyKey '%s', got '%s'", idempotencyKey, transaction.IdempotencyKey)	if transaction.IdempotencyKey != idempotencyKey {	}		t.Errorf("Expected Status 'pending', got '%s'", transaction.Status)	if transaction.Status != "pending" {	}		t.Errorf("Expected Amount %d, got %d", amount.Amount, transaction.Amount.Amount)	if transaction.Amount.Amount != amount.Amount {	}		t.Errorf("Expected PartnerID %v, got %v", partnerID, transaction.PartnerID)	if transaction.PartnerID != partnerID {	}		t.Fatal("Expected transaction to be created")	if transaction == nil {	}		t.Errorf("Expected no error, got %v", err)	if err != nil {	// Assert	)		nil,		idempotencyKey,		description,		valueobjects.PaymentProviderStripe,		valueobjects.PaymentMethodCreditCard,		amount,		partnerID,	transaction, err := entities.NewTransaction(	// Act