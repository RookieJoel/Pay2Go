package transaction
// Package transaction contains use cases for transaction operations
// Use cases orchestrate the flow of data to/from entities
// They contain application-specific business rules
package transaction







































































































































































































































































}	return transactions, total, nil		}		return nil, 0, fmt.Errorf("failed to list transactions: %w", err)	if err != nil {	transactions, total, err := uc.transactionRepo.List(ctx, filter)		}		filter.Limit = 100 // Max 100 per page	if filter.Limit > 100 {	}		filter.Limit = 20	if filter.Limit == 0 {	// Set default pagination if not provided		filter.PartnerID = &partnerID	// Enforce partner isolationfunc (uc *ListTransactionsUseCase) Execute(ctx context.Context, partnerID uuid.UUID, filter ports.TransactionFilter) ([]*entities.Transaction, int64, error) {// Execute lists transactions with filters}	}		transactionRepo: transactionRepo,	return &ListTransactionsUseCase{func NewListTransactionsUseCase(transactionRepo ports.TransactionRepository) *ListTransactionsUseCase {// NewListTransactionsUseCase creates a new instance}	transactionRepo ports.TransactionRepositorytype ListTransactionsUseCase struct {// ListTransactionsUseCase handles listing transactions with filtering}	return transaction, nil		}		_ = uc.cache.Set(ctx, cacheKey, transaction, 300)		cacheKey := fmt.Sprintf("transaction:%s", transactionID.String())	if uc.cache != nil {	// Cache the result (TTL: 5 minutes)		}		return nil, errors.ErrUnauthorizedOperation	if transaction.PartnerID != partnerID {	// Authorization: Verify partner owns this transaction		}		return nil, errors.ErrTransactionNotFound	if transaction == nil {		}		return nil, fmt.Errorf("failed to get transaction: %w", err)	if err != nil {	transaction, err := uc.transactionRepo.GetByID(ctx, transactionID)	// Get from database		}		}			}				return txn, nil				}					return nil, errors.ErrUnauthorizedOperation				if txn.PartnerID != partnerID {				// Verify partner owns this transaction (authorization)			if txn, ok := cached.(*entities.Transaction); ok {		if cached != nil {		cached, _ := uc.cache.Get(ctx, cacheKey)		cacheKey := fmt.Sprintf("transaction:%s", transactionID.String())	if uc.cache != nil {	// Try cache first (if available)func (uc *GetTransactionUseCase) Execute(ctx context.Context, transactionID uuid.UUID, partnerID uuid.UUID) (*entities.Transaction, error) {// Execute retrieves a transaction by ID}	}		cache:           cache,		transactionRepo: transactionRepo,	return &GetTransactionUseCase{) *GetTransactionUseCase {	cache ports.CacheService,	transactionRepo ports.TransactionRepository,func NewGetTransactionUseCase(// NewGetTransactionUseCase creates a new instance}	cache           ports.CacheService	transactionRepo ports.TransactionRepositorytype GetTransactionUseCase struct {// GetTransactionUseCase handles the business logic for retrieving a transaction}	}, nil		CreatedAt:     transaction.CreatedAt,		Status:        string(transaction.Status),		TransactionID: transaction.ID,	return &CreateTransactionOutput{	// Step 10: Return output		}		})			},				"status":   transaction.Status,				"currency": input.Currency,				"amount":   input.Amount,			Changes: map[string]interface{}{			RequestID:    transaction.RequestID,			UserAgent:    input.UserAgent,			IPAddress:    input.IPAddress,			ResourceID:   transaction.ID,			ResourceType: "transaction",			Action:       "create_transaction",			PartnerID:    input.PartnerID,		_ = uc.auditLogger.LogAction(ctx, ports.AuditAction{	if uc.auditLogger != nil {	// Step 9: Log audit event		}		return nil, fmt.Errorf("failed to create transaction: %w", err)	if err := uc.transactionRepo.Create(ctx, transaction); err != nil {	// Step 8: Persist transaction		transaction.UserAgent = input.UserAgent	transaction.IPAddress = input.IPAddress	}		}			transaction.SetMetadata(key, value)		for key, value := range input.Metadata {	if input.Metadata != nil {	}		transaction.Description = input.Description	if input.Description != "" {	}		transaction.CustomerPhone = input.CustomerPhone	if input.CustomerPhone != "" {	}		transaction.CustomerName = input.CustomerName	if input.CustomerName != "" {	// Step 7: Set optional fields		}		return nil, fmt.Errorf("failed to create transaction entity: %w", err)	if err != nil {	)		input.CustomerEmail,		provider,		paymentMethod,		money,		input.IdempotencyKey,		input.PartnerID,	transaction, err := entities.NewTransaction(	// Step 6: Create Transaction entity (validates business rules)		}		return nil, fmt.Errorf("invalid payment provider: %w", err)	if err != nil {	provider, err := valueobjects.NewPaymentProvider(input.Provider)	// Step 5: Create PaymentProvider value object (validates provider)		}		return nil, fmt.Errorf("invalid payment method: %w", err)	if err != nil {	paymentMethod, err := valueobjects.NewPaymentMethod(input.PaymentMethod)	// Step 4: Create PaymentMethod value object (validates payment method)		}		return nil, fmt.Errorf("invalid money: %w", err)	if err != nil {	money, err := valueobjects.NewMoney(input.Amount, input.Currency)	// Step 3: Create Money value object (validates amount and currency)		}		}, nil			CreatedAt:     existingTxn.CreatedAt,			Status:        string(existingTxn.Status),			TransactionID: existingTxn.ID,		return &CreateTransactionOutput{		// Return existing transaction (idempotent behavior)	if err == nil && existingTxn != nil {	existingTxn, err := uc.transactionRepo.GetByIdempotencyKey(ctx, input.PartnerID, input.IdempotencyKey)	// Step 2: Check for duplicate transaction (idempotency)		}		return nil, errors.ErrPartnerInactive	if !partner.IsActive {		}		return nil, errors.ErrPartnerNotFound	if partner == nil {		}		return nil, fmt.Errorf("failed to get partner: %w", err)	if err != nil {	partner, err := uc.partnerRepo.GetByID(ctx, input.PartnerID)	// Step 1: Validate partner exists and is activefunc (uc *CreateTransactionUseCase) Execute(ctx context.Context, input CreateTransactionInput) (*CreateTransactionOutput, error) {// This is the main orchestration logic// Execute executes the create transaction use case}	}		cache:           cache,		auditLogger:     auditLogger,		paymentGateway:  paymentGateway,		partnerRepo:     partnerRepo,		transactionRepo: transactionRepo,	return &CreateTransactionUseCase{) *CreateTransactionUseCase {	cache ports.CacheService,	auditLogger ports.AuditLogger,	paymentGateway ports.PaymentGateway,	partnerRepo ports.PartnerRepository,	transactionRepo ports.TransactionRepository,func NewCreateTransactionUseCase(// Dependency Injection: all dependencies are interfaces (ports)// NewCreateTransactionUseCase creates a new instance of the use case}	cache           ports.CacheService	auditLogger     ports.AuditLogger	paymentGateway  ports.PaymentGateway	partnerRepo     ports.PartnerRepository	transactionRepo ports.TransactionRepositorytype CreateTransactionUseCase struct {// CreateTransactionUseCase handles the business logic for creating transactions}	CreatedAt     time.Time	Status        string	TransactionID uuid.UUIDtype CreateTransactionOutput struct {// CreateTransactionOutput represents the output of transaction creation}	UserAgent      string	IPAddress      string	Metadata       map[string]interface{}	Description    string	CustomerPhone  string	CustomerName   string	CustomerEmail  string	Provider       string	PaymentMethod  string	Currency       string	Amount         float64	IdempotencyKey string	PartnerID      uuid.UUIDtype CreateTransactionInput struct {// CreateTransactionInput represents the input for creating a transaction)	"Pay2Go/internal/usecases/ports"	"Pay2Go/internal/domain/valueobjects"	"Pay2Go/internal/domain/errors"	"Pay2Go/internal/domain/entities"	"github.com/google/uuid"	"time"	"fmt"	"context"import (