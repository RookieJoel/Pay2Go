package postgres
// Package postgres implements repository interfaces using PostgreSQL
package postgres

import (



























































































































































































































































































}	return txns, err	txns, _, err := r.List(ctx, filter)	}		Offset: offset,		Limit:  limit,		Status: &status,	filter := ports.TransactionFilter{func (r *TransactionRepository) GetByStatus(ctx context.Context, status entities.TransactionStatus, limit, offset int) ([]*entities.Transaction, error) {// GetByStatus retrieves transactions by status}	return txns, err	txns, _, err := r.List(ctx, filter)	}		Offset:    offset,		Limit:     limit,		PartnerID: &partnerID,	filter := ports.TransactionFilter{func (r *TransactionRepository) GetByPartnerID(ctx context.Context, partnerID uuid.UUID, limit, offset int) ([]*entities.Transaction, error) {// GetByPartnerID retrieves transactions for a specific partner}	return transactions, total, nil	_ = r.db.QueryRowContext(ctx, countQuery).Scan(&total)	var total int64	countQuery := "SELECT COUNT(*) FROM transactions WHERE deleted_at IS NULL"	// Get total count	}		transactions[i] = txn		}			return nil, 0, err		if err != nil {		txn, err := r.GetByID(ctx, id)	for i, id := range ids {	transactions := make([]*entities.Transaction, len(ids))	// Get full transaction details	}		ids = append(ids, id)		}			return nil, 0, err		if err := rows.Scan(&id); err != nil {		var id uuid.UUID	for rows.Next() {	var ids []uuid.UUID	defer rows.Close()	}		return nil, 0, fmt.Errorf("failed to list transactions: %w", err)	if err != nil {	rows, err := r.db.QueryContext(ctx, query, args...)	args = append(args, filter.Limit, filter.Offset)	query += fmt.Sprintf(" LIMIT $%d OFFSET $%d", argPos, argPos+1)	query += " ORDER BY created_at DESC"	}		argPos++		args = append(args, string(*filter.Status))		query += fmt.Sprintf(" AND status = $%d", argPos)	if filter.Status != nil {	}		argPos++		args = append(args, *filter.PartnerID)		query += fmt.Sprintf(" AND partner_id = $%d", argPos)	if filter.PartnerID != nil {	argPos := 1	args := []interface{}{}	`		WHERE deleted_at IS NULL		SELECT id FROM transactions	query := `	// Build query dynamically based on filterfunc (r *TransactionRepository) List(ctx context.Context, filter ports.TransactionFilter) ([]*entities.Transaction, int64, error) {// List retrieves transactions with pagination}	return nil	}		return fmt.Errorf("failed to update transaction: %w", err)	if err != nil {	)		txn.ID,		txn.FailedAt,		txn.ProcessedAt,		txn.UpdatedAt,		txn.RetryCount,		txn.ErrorMessage,		txn.ErrorCode,		txn.ProviderTransactionID,		string(txn.Status),	_, err := r.db.ExecContext(ctx, query,	`		WHERE id = $9			failed_at = $8			processed_at = $7,			updated_at = $6,			retry_count = $5,			error_message = $4,			error_code = $3,			provider_transaction_id = $2,			status = $1,		UPDATE transactions SET	query := `func (r *TransactionRepository) Update(ctx context.Context, txn *entities.Transaction) error {// Update updates an existing transaction}	return r.GetByID(ctx, id)	}		return nil, fmt.Errorf("failed to check idempotency: %w", err)		}			return nil, nil // Not found, not an error		if err == sql.ErrNoRows {	if err != nil {	err := r.db.QueryRowContext(ctx, query, partnerID, idempotencyKey).Scan(&id)	var id uuid.UUID	`		WHERE partner_id = $1 AND idempotency_key = $2 AND deleted_at IS NULL		SELECT id FROM transactions	query := `func (r *TransactionRepository) GetByIdempotencyKey(ctx context.Context, partnerID uuid.UUID, idempotencyKey string) (*entities.Transaction, error) {// GetByIdempotencyKey retrieves a transaction by partner and idempotency key}	return &txn, nil	}		json.Unmarshal(metadataJSON, &txn.Metadata)	if len(metadataJSON) > 0 {	}		txn.ProviderTransactionID = providerTxnID.String	if providerTxnID.Valid {	txn.Status = entities.TransactionStatus(status)	txn.Provider, _ = valueobjects.NewPaymentProvider(provider)	txn.PaymentMethod, _ = valueobjects.NewPaymentMethod(paymentMethod)	txn.Amount = money	money, _ := valueobjects.NewMoney(amount, currency)	// Reconstruct value objects	}		return nil, fmt.Errorf("failed to get transaction: %w", err)		}			return nil, errors.ErrTransactionNotFound		if err == sql.ErrNoRows {	if err != nil {	)		&txn.FailedAt,		&txn.ProcessedAt,		&txn.UpdatedAt,		&txn.CreatedAt,		&txn.RetryCount,		&txn.ErrorMessage,		&txn.ErrorCode,		&txn.RequestID,		&txn.UserAgent,		&txn.IPAddress,		&metadataJSON,		&txn.Description,		&txn.CustomerPhone,		&txn.CustomerName,		&txn.CustomerEmail,		&status,		&providerTxnID,		&provider,		&paymentMethod,		&currency,		&amount,		&txn.IdempotencyKey,		&txn.PartnerID,		&txn.ID,	err := r.db.QueryRowContext(ctx, query, id).Scan(	var providerTxnID sql.NullString	var status string	var provider string	var paymentMethod string	var currency string	var amount float64	var metadataJSON []byte	var txn entities.Transaction	`		WHERE id = $1 AND deleted_at IS NULL		FROM transactions			   processed_at, failed_at			   error_message, retry_count, created_at, updated_at,			   metadata, ip_address, user_agent, request_id, error_code,			   customer_email, customer_name, customer_phone, description,			   payment_method, provider, provider_transaction_id, status,		SELECT id, partner_id, idempotency_key, amount, currency,	query := `func (r *TransactionRepository) GetByID(ctx context.Context, id uuid.UUID) (*entities.Transaction, error) {// GetByID retrieves a transaction by ID}	return nil	}		return fmt.Errorf("failed to create transaction: %w", err)		}			}				return errors.ErrDuplicateTransaction			if pqErr.Code == "23505" { // Unique violation		if pqErr, ok := err.(*pq.Error); ok {	if err != nil {	)		txn.UpdatedAt,		txn.CreatedAt,		txn.RetryCount,		txn.RequestID,		txn.UserAgent,		txn.IPAddress,		metadataJSON,		txn.Description,		txn.CustomerPhone,		txn.CustomerName,		txn.CustomerEmail,		string(txn.Status),		txn.Provider.String(),		txn.PaymentMethod.String(),		txn.Amount.Currency.String(),		txn.Amount.Amount,		txn.IdempotencyKey,		txn.PartnerID,		txn.ID,	_, err := r.db.ExecContext(ctx, query,	metadataJSON, _ := json.Marshal(txn.Metadata)	`		)			$14, $15, $16, $17, $18, $19			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13,		) VALUES (			created_at, updated_at			ip_address, user_agent, request_id, retry_count,			customer_name, customer_phone, description, metadata,			payment_method, provider, status, customer_email,			id, partner_id, idempotency_key, amount, currency,		INSERT INTO transactions (	query := `func (r *TransactionRepository) Create(ctx context.Context, txn *entities.Transaction) error {// Create creates a new transaction}	return &TransactionRepository{db: db}func NewTransactionRepository(db *sql.DB) *TransactionRepository {// NewTransactionRepository creates a new PostgreSQL transaction repository}	db *sql.DBtype TransactionRepository struct {// TransactionRepository implements ports.TransactionRepository for PostgreSQL)	"Pay2Go/internal/usecases/ports"	"Pay2Go/internal/domain/valueobjects"	"Pay2Go/internal/domain/errors"	"Pay2Go/internal/domain/entities"	"github.com/lib/pq"	"github.com/google/uuid"	"fmt"	"encoding/json"	"database/sql"	"context"