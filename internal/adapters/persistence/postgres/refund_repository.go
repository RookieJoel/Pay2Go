package postgres
package postgres

import (
	"context"
	"database/sql"



















































































































































































}	return total, nil	}		return 0, fmt.Errorf("failed to get total refunded amount: %w", err)	if err != nil {	err := r.db.QueryRowContext(ctx, query, transactionID).Scan(&total)	var total float64	`		  AND deleted_at IS NULL		  AND status = 'completed'		WHERE transaction_id = $1		FROM refunds		SELECT COALESCE(SUM(amount), 0)	query := `func (r *RefundRepository) GetTotalRefundedAmount(ctx context.Context, transactionID uuid.UUID) (float64, error) {// GetTotalRefundedAmount calculates total refunded amount for a transaction}	return nil	}		return fmt.Errorf("failed to update refund: %w", err)	if err != nil {	)		refund.ID,		refund.ProcessedAt,		refund.UpdatedAt,		refund.ErrorMessage,		refund.ErrorCode,		refund.ProviderRefundID,		string(refund.Status),	_, err := r.db.ExecContext(ctx, query,	`		WHERE id = $7			processed_at = $6			updated_at = $5,			error_message = $4,			error_code = $3,			provider_refund_id = $2,			status = $1,		UPDATE refunds SET	query := `func (r *RefundRepository) Update(ctx context.Context, refund *entities.Refund) error {// Update updates an existing refund}	return refunds, nil	}		refunds = append(refunds, refund)		}			return nil, err		if err != nil {		refund, err := r.GetByID(ctx, id)		}			return nil, err		if err := rows.Scan(&id); err != nil {		var id uuid.UUID	for rows.Next() {	var refunds []*entities.Refund	defer rows.Close()	}		return nil, fmt.Errorf("failed to list refunds: %w", err)	if err != nil {	rows, err := r.db.QueryContext(ctx, query, transactionID)	`		ORDER BY created_at DESC		WHERE transaction_id = $1 AND deleted_at IS NULL		SELECT id FROM refunds	query := `func (r *RefundRepository) GetByTransactionID(ctx context.Context, transactionID uuid.UUID) ([]*entities.Refund, error) {// GetByTransactionID retrieves all refunds for a transaction}	return &refund, nil	}		refund.ProviderRefundID = providerRefundID.String	if providerRefundID.Valid {	refund.Status = entities.RefundStatus(status)	refund.Amount = money	money, _ := valueobjects.NewMoney(amount, currency)	// Reconstruct value objects	}		return nil, fmt.Errorf("failed to get refund: %w", err)		}			return nil, errors.NewDomainError("REFUND_NOT_FOUND", "refund not found", nil)		if err == sql.ErrNoRows {	if err != nil {	)		&refund.ProcessedAt,		&refund.UpdatedAt,		&refund.CreatedAt,		&refund.ErrorMessage,		&refund.ErrorCode,		&providerRefundID,		&status,		&refund.Reason,		&currency,		&amount,		&refund.TransactionID,		&refund.ID,	err := r.db.QueryRowContext(ctx, query, id).Scan(	var providerRefundID sql.NullString	var status string	var currency string	var amount float64	var refund entities.Refund	`		WHERE id = $1 AND deleted_at IS NULL		FROM refunds			   created_at, updated_at, processed_at			   provider_refund_id, error_code, error_message,		SELECT id, transaction_id, amount, currency, reason, status,	query := `func (r *RefundRepository) GetByID(ctx context.Context, id uuid.UUID) (*entities.Refund, error) {// GetByID retrieves a refund by ID}	return nil	}		return fmt.Errorf("failed to create refund: %w", err)	if err != nil {	)		refund.UpdatedAt,		refund.CreatedAt,		string(refund.Status),		refund.Reason,		refund.Amount.Currency.String(),		refund.Amount.Amount,		refund.TransactionID,		refund.ID,	_, err := r.db.ExecContext(ctx, query,	`		)			$1, $2, $3, $4, $5, $6, $7, $8		) VALUES (			created_at, updated_at			id, transaction_id, amount, currency, reason, status,		INSERT INTO refunds (	query := `func (r *RefundRepository) Create(ctx context.Context, refund *entities.Refund) error {// Create creates a new refund}	return &RefundRepository{db: db}func NewRefundRepository(db *sql.DB) *RefundRepository {// NewRefundRepository creates a new PostgreSQL refund repository}	db *sql.DBtype RefundRepository struct {// RefundRepository implements ports.RefundRepository for PostgreSQL)	"Pay2Go/internal/domain/valueobjects"	"Pay2Go/internal/domain/errors"	"Pay2Go/internal/domain/entities"	"github.com/google/uuid"	"fmt"