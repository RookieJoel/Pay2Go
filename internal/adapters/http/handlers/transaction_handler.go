package handlers
// Package handlers contains HTTP request handlers
package handlers

import (


















































































































































































































































































































































}	return filter	}		filter.DateTo = &req.DateTo	if req.DateTo != "" {	}		filter.DateFrom = &req.DateFrom	if req.DateFrom != "" {	}		filter.Status = &status		status := entities.TransactionStatus(req.Status)	if req.Status != "" {	}		Offset: req.Offset,		Limit:  req.Limit,	filter := transaction.TransactionFilter{func buildTransactionFilter(req dto.ListTransactionsRequest) transaction.TransactionFilter {}	}		ProcessedAt:           txn.ProcessedAt,		UpdatedAt:             txn.UpdatedAt,		CreatedAt:             txn.CreatedAt,		ErrorMessage:          txn.ErrorMessage,		ErrorCode:             txn.ErrorCode,		Metadata:              txn.Metadata,		Description:           txn.Description,		CustomerPhone:         txn.CustomerPhone,		CustomerName:          txn.CustomerName,		CustomerEmail:         txn.CustomerEmail,		Status:                string(txn.Status),		ProviderTransactionID: txn.ProviderTransactionID,		Provider:              txn.Provider.String(),		PaymentMethod:         txn.PaymentMethod.String(),		Currency:              txn.Amount.Currency.String(),		Amount:                txn.Amount.Amount,		IdempotencyKey:        txn.IdempotencyKey,		PartnerID:             txn.PartnerID.String(),		ID:                    txn.ID.String(),	return dto.GetTransactionResponse{func (h *TransactionHandler) mapTransactionToDTO(txn *entities.Transaction) dto.GetTransactionResponse {// Helper functions}	return c.Status(fiber.StatusCreated).JSON(response)	}		CreatedAt:     refund.CreatedAt,		Reason:        refund.Reason,		Status:        string(refund.Status),		Currency:      refund.Amount.Currency.String(),		Amount:        refund.Amount.Amount,		TransactionID: refund.TransactionID.String(),		RefundID:      refund.ID.String(),	response := dto.RefundTransactionResponse{	// Return response	}		})			Message: err.Error(),			Error:   "refund_failed",		return c.Status(fiber.StatusInternalServerError).JSON(dto.ErrorResponse{	if err != nil {	refund, err := h.refundUseCase.Execute(c.Context(), input)	// Execute use case	}		UserAgent:     c.Get("User-Agent"),		IPAddress:     c.IP(),		Reason:        req.Reason,		Currency:      req.Currency,		Amount:        req.Amount,		PartnerID:     partnerID,		TransactionID: txnID,	input := transaction.RefundTransactionInput{	// Create use case input	}		})			Message: "invalid request body",			Error:   "invalid_request",		return c.Status(fiber.StatusBadRequest).JSON(dto.ErrorResponse{	if err := c.BodyParser(&req); err != nil {	var req dto.RefundTransactionRequest	// Parse request body	}		})			Message: "invalid transaction ID format",			Error:   "invalid_transaction_id",		return c.Status(fiber.StatusBadRequest).JSON(dto.ErrorResponse{	if err != nil {	txnID, err := uuid.Parse(txnIDStr)	txnIDStr := c.Params("id")	// Parse transaction ID	}		})			Message: "authentication required",			Error:   "unauthorized",		return c.Status(fiber.StatusUnauthorized).JSON(dto.ErrorResponse{	if err != nil {	partnerID, err := middleware.GetPartnerID(c)	// Get partner IDfunc (h *TransactionHandler) RefundTransaction(c *fiber.Ctx) error {// RefundTransaction handles POST /api/v1/transactions/:id/refund}	})		"message": "payment processing initiated",	return c.JSON(fiber.Map{	}		})			Message: err.Error(),			Error:   "payment_processing_failed",		return c.Status(fiber.StatusInternalServerError).JSON(dto.ErrorResponse{	if err := h.processTxnUseCase.Execute(c.Context(), txnID); err != nil {	// Execute use case	}		})			Message: "invalid transaction ID format",			Error:   "invalid_transaction_id",		return c.Status(fiber.StatusBadRequest).JSON(dto.ErrorResponse{	if err != nil {	txnID, err := uuid.Parse(txnIDStr)	txnIDStr := c.Params("id")	// Parse transaction ID	}		})			Message: "authentication required",			Error:   "unauthorized",		return c.Status(fiber.StatusUnauthorized).JSON(dto.ErrorResponse{	if err != nil {	_, err := middleware.GetPartnerID(c)	// Get partner IDfunc (h *TransactionHandler) ProcessPayment(c *fiber.Ctx) error {// ProcessPayment handles POST /api/v1/transactions/:id/process}	return c.JSON(response)	}		Offset:       req.Offset,		Limit:        req.Limit,		Total:        total,		Transactions: txnDTOs,	response := dto.ListTransactionsResponse{	}		txnDTOs[i] = h.mapTransactionToDTO(txn)	for i, txn := range transactions {	txnDTOs := make([]dto.GetTransactionResponse, len(transactions))	// Map to response DTOs	}		})			Message: err.Error(),			Error:   "failed_to_list_transactions",		return c.Status(fiber.StatusInternalServerError).JSON(dto.ErrorResponse{	if err != nil {	transactions, total, err := h.listTxnUseCase.Execute(c.Context(), partnerID, filter)	// Execute use case	filter := buildTransactionFilter(req)	// Build filter	}		req.Limit = 100	if req.Limit > 100 {	}		req.Limit = 20	if req.Limit == 0 {	// Set defaults	}		})			Message: err.Error(),			Error:   "invalid_query_parameters",		return c.Status(fiber.StatusBadRequest).JSON(dto.ErrorResponse{	if err := c.QueryParser(&req); err != nil {	var req dto.ListTransactionsRequest	// Parse query parameters	}		})			Message: "authentication required",			Error:   "unauthorized",		return c.Status(fiber.StatusUnauthorized).JSON(dto.ErrorResponse{	if err != nil {	partnerID, err := middleware.GetPartnerID(c)	// Get partner IDfunc (h *TransactionHandler) ListTransactions(c *fiber.Ctx) error {// ListTransactions handles GET /api/v1/transactions}	return c.JSON(response)	response := h.mapTransactionToDTO(txn)	// Map to response DTO	}		})			Message: err.Error(),			Error:   "transaction_not_found",		return c.Status(fiber.StatusNotFound).JSON(dto.ErrorResponse{	if err != nil {	txn, err := h.getTxnUseCase.Execute(c.Context(), txnID, partnerID)	// Execute use case	}		})			Message: "invalid transaction ID format",			Error:   "invalid_transaction_id",		return c.Status(fiber.StatusBadRequest).JSON(dto.ErrorResponse{	if err != nil {	txnID, err := uuid.Parse(txnIDStr)	txnIDStr := c.Params("id")	// Parse transaction ID from URL	}		})			Message: "authentication required",			Error:   "unauthorized",		return c.Status(fiber.StatusUnauthorized).JSON(dto.ErrorResponse{	if err != nil {	partnerID, err := middleware.GetPartnerID(c)	// Get partner IDfunc (h *TransactionHandler) GetTransaction(c *fiber.Ctx) error {// GetTransaction handles GET /api/v1/transactions/:id}	return c.Status(fiber.StatusCreated).JSON(response)	}		CreatedAt:     output.CreatedAt,		Currency:      req.Currency,		Amount:        req.Amount,		Status:        output.Status,		TransactionID: output.TransactionID.String(),	response := dto.CreateTransactionResponse{	// Return response	}		})			Message: err.Error(),			Error:   "transaction_creation_failed",		return c.Status(fiber.StatusInternalServerError).JSON(dto.ErrorResponse{	if err != nil {	output, err := h.createTxnUseCase.Execute(c.Context(), input)	// Execute use case	}		UserAgent:      c.Get("User-Agent"),		IPAddress:      c.IP(),		Metadata:       req.Metadata,		Description:    req.Description,		CustomerPhone:  req.CustomerPhone,		CustomerName:   req.CustomerName,		CustomerEmail:  req.CustomerEmail,		Provider:       req.Provider,		PaymentMethod:  req.PaymentMethod,		Currency:       req.Currency,		Amount:         req.Amount,		IdempotencyKey: req.IdempotencyKey,		PartnerID:      partnerID,	input := transaction.CreateTransactionInput{	// Create use case input	}		})			Message: "missing required fields",			Error:   "validation_error",		return c.Status(fiber.StatusBadRequest).JSON(dto.ErrorResponse{	if req.IdempotencyKey == "" || req.Amount <= 0 || req.Currency == "" {	// Validate request (in production, use proper validator)	}		})			Message: "invalid request body",			Error:   "invalid_request",		return c.Status(fiber.StatusBadRequest).JSON(dto.ErrorResponse{	if err := c.BodyParser(&req); err != nil {	var req dto.CreateTransactionRequest	// Parse request body	}		})			Message: "authentication required",			Error:   "unauthorized",		return c.Status(fiber.StatusUnauthorized).JSON(dto.ErrorResponse{	if err != nil {	partnerID, err := middleware.GetPartnerID(c)	// Get partner ID from context (set by auth middleware)func (h *TransactionHandler) CreateTransaction(c *fiber.Ctx) error {// CreateTransaction handles POST /api/v1/transactions}	}		refundUseCase:     refundUseCase,		processTxnUseCase: processTxnUseCase,		listTxnUseCase:    listTxnUseCase,		getTxnUseCase:     getTxnUseCase,		createTxnUseCase:  createTxnUseCase,	return &TransactionHandler{) *TransactionHandler {	refundUseCase *transaction.RefundTransactionUseCase,	processTxnUseCase *transaction.ProcessPaymentUseCase,	listTxnUseCase *transaction.ListTransactionsUseCase,	getTxnUseCase *transaction.GetTransactionUseCase,	createTxnUseCase *transaction.CreateTransactionUseCase,func NewTransactionHandler(// NewTransactionHandler creates a new transaction handler}	refundUseCase     *transaction.RefundTransactionUseCase	processTxnUseCase *transaction.ProcessPaymentUseCase	listTxnUseCase    *transaction.ListTransactionsUseCase	getTxnUseCase     *transaction.GetTransactionUseCase	createTxnUseCase  *transaction.CreateTransactionUseCasetype TransactionHandler struct {// TransactionHandler handles transaction-related HTTP requests)	"Pay2Go/internal/usecases/transaction"	"Pay2Go/internal/domain/entities"	"Pay2Go/internal/adapters/http/middleware"	"Pay2Go/internal/adapters/http/dto"	"github.com/google/uuid"	"github.com/gofiber/fiber/v2"