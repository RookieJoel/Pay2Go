package middleware
package middleware

import (
	"sync"
	"time"

























































































































}	return b	}		return a	if a < b {func min(a, b int) int {}	}		rl.mu.Unlock()		}			b.mu.Unlock()			}				delete(rl.buckets, key)			if now.Sub(b.lastRefill) > 30*time.Minute {			b.mu.Lock()		for key, b := range rl.buckets {		now := time.Now()		rl.mu.Lock()	for range ticker.C {	defer ticker.Stop()	ticker := time.NewTicker(10 * time.Minute)func (rl *RateLimiter) cleanup() {}	return nil	b.tokens--	// Consume token	}		return fiber.ErrTooManyRequests	if b.tokens <= 0 {	// Check if token available	}		b.lastRefill = now		b.tokens = min(b.capacity, b.tokens+tokensToAdd)	if tokensToAdd > 0 {	tokensToAdd := int(elapsed.Minutes() * float64(b.refillRate))	elapsed := now.Sub(b.lastRefill)	now := time.Now()	// Refill tokens based on time elapsed	defer b.mu.Unlock()	b.mu.Lock()	rl.mu.Unlock()	}		rl.buckets[key] = b		}			lastRefill: time.Now(),			refillRate: capacity,			capacity:   capacity,			tokens:     capacity,		b = &bucket{	if !exists {	b, exists := rl.buckets[key]	rl.mu.Lock()func (rl *RateLimiter) checkLimit(c *fiber.Ctx, key string, capacity int) error {}	return c.Next()	}		})			"message": "Too many requests. Please try again later.",			"error":   "rate_limit_exceeded",		return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{	if rl.checkLimit(c, key, rateLimit) != nil {	key := partnerID.(string)	rateLimit := 100 // Default: 100 requests per minute	// In production, get this from partner config	}		return c.Next()	if partner == nil {	partner := c.Locals("partner")	// Get partner-specific rate limit	}		return rl.checkLimit(c, c.IP(), 60) // 60 requests per minute for unauthenticated		// If not authenticated, use IP-based rate limiting	if partnerID == nil {	partnerID := c.Locals("partner_id")	// Get partner ID from context (set by auth middleware)func (rl *RateLimiter) Handle(c *fiber.Ctx) error {// Handle checks rate limit and rejects if exceeded}	return rl	go rl.cleanup()	// Cleanup goroutine to remove stale buckets	}		buckets: make(map[string]*bucket),	rl := &RateLimiter{func NewRateLimiter() *RateLimiter {// NewRateLimiter creates a new rate limiter}	mu           sync.Mutex	lastRefill   time.Time	refillRate   int       // tokens per minute	capacity     int	tokens       inttype bucket struct {}	mu      sync.RWMutex	buckets map[string]*buckettype RateLimiter struct {// RateLimiter implements token bucket rate limiting per partner)	"github.com/gofiber/fiber/v2"