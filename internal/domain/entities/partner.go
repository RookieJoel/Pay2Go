package entities
package entities

import (
	"crypto/rand"
	"encoding/base64"
	"time"



















































































































































































}	return string(hashedBytes), nil	}		return "", err	if err != nil {	hashedBytes, err := bcrypt.GenerateFromPassword([]byte(apiKey), bcrypt.DefaultCost)func hashAPIKey(apiKey string) (string, error) {// hashAPIKey hashes an API key using bcrypt}	return base64.URLEncoding.EncodeToString(bytes), nil	}		return "", err	if _, err := rand.Read(bytes); err != nil {	bytes := make([]byte, 32)func generateAPIKey() (string, error) {// generateAPIKey generates a cryptographically secure API key// Helper functions}	return p.DeletedAt != nilfunc (p *Partner) IsDeleted() bool {// IsDeleted checks if partner is soft-deleted}	p.IsActive = false	p.UpdatedAt = now	p.DeletedAt = &now	now := time.Now()func (p *Partner) SoftDelete() {// SoftDelete marks partner as deleted}	return val, exists	val, exists := p.Metadata[key]	}		return nil, false	if p.Metadata == nil {func (p *Partner) GetMetadata(key string) (interface{}, bool) {// GetMetadata retrieves metadata value}	p.UpdatedAt = time.Now()	p.Metadata[key] = value	}		p.Metadata = make(map[string]interface{})	if p.Metadata == nil {func (p *Partner) SetMetadata(key string, value interface{}) {// SetMetadata sets metadata with validation}	return nil		p.UpdatedAt = time.Now()	p.RateLimitPerMinute = limit		}		return errors.NewValidationError("rate_limit", "cannot exceed 10000")	if limit > 10000 {		}		return errors.NewValidationError("rate_limit", "must be at least 1")	if limit < 1 {func (p *Partner) SetRateLimit(limit int) error {// SetRateLimit sets the rate limit for this partner}	return nil		p.UpdatedAt = time.Now()	p.WebhookSecret = secret	p.WebhookURL = url		}		return errors.NewValidationError("webhook_url", "cannot be empty")	if url == "" {func (p *Partner) SetWebhook(url, secret string) error {// SetWebhook sets the webhook configuration}	p.UpdatedAt = time.Now()	p.IsActive = falsefunc (p *Partner) Deactivate() {// Deactivate deactivates the partner account}	p.UpdatedAt = time.Now()	p.IsActive = truefunc (p *Partner) Activate() {// Activate activates the partner account}	return nil		}		return errors.ErrInvalidAPIKey	if err != nil {	err := bcrypt.CompareHashAndPassword([]byte(p.APIKeyHash), []byte(apiKey))		}		return errors.ErrPartnerInactive	if !p.IsActive {func (p *Partner) ValidateAPIKey(apiKey string) error {// ValidateAPIKey validates the provided API key against the stored hash}	return partner, nil		}		Metadata:           make(map[string]interface{}),		UpdatedAt:          now,		CreatedAt:          now,		RateLimitPerMinute: 100, // Default rate limit		IsActive:           true,		APIKeyPrefix:       apiKey[:8], // Store prefix for identification		APIKeyHash:         hashedKey,		Email:              email,		Name:               name,		ID:                 uuid.New(),	partner := &Partner{		now := time.Now()		}		return nil, err	if err != nil {	hashedKey, err := hashAPIKey(apiKey)	// Hash API key		}		return nil, err	if err != nil {	apiKey, err := generateAPIKey()	// Generate API key		}		return nil, errors.NewValidationError("email", "cannot be empty")	if email == "" {		}		return nil, errors.NewValidationError("name", "cannot be empty")	if name == "" {	// Validate required fieldsfunc NewPartner(name, email string) (*Partner, error) {// NewPartner creates a new partner with validation}	DeletedAt   *time.Time	UpdatedAt   time.Time	CreatedAt   time.Time	// Timestamps		Metadata    map[string]interface{}	// Additional data		WebhookSecret       string	WebhookURL          string	RateLimitPerMinute  int	IsActive            bool	// Configuration		APIKeyPrefix string // First 8 characters for identification	APIKeyHash   string // Hashed with bcrypt	// Authentication		Email       string	Name        string	ID          uuid.UUID	// Identitytype Partner struct {// Partner represents a merchant/client using the payment orchestration API)	"Pay2Go/internal/domain/errors"	"golang.org/x/crypto/bcrypt"	"github.com/google/uuid"