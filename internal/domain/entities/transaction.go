package entities
// Package entities contains the core domain entities (Aggregates)
// These represent the business objects with identity, lifecycle, and business logic
package entities

import (




































































































































































































































































































}	return t.DeletedAt != nilfunc (t *Transaction) IsDeleted() bool {// IsDeleted checks if transaction is soft-deleted}	t.UpdatedAt = now	t.DeletedAt = &now	now := time.Now()func (t *Transaction) SoftDelete() {// SoftDelete marks transaction as deleted (soft delete)}	return t.Status == StatusProcessingfunc (t *Transaction) IsProcessing() bool {// IsProcessing checks if transaction is being processed}	return t.Status == StatusPendingfunc (t *Transaction) IsPending() bool {// IsPending checks if transaction is pending}	return t.Status == StatusFailed || t.Status == StatusCancelledfunc (t *Transaction) IsFailed() bool {// IsFailed checks if transaction has failed}		t.Status == StatusPartiallyRefunded		t.Status == StatusRefunded ||	return t.Status == StatusCompleted ||func (t *Transaction) IsCompleted() bool {// IsCompleted checks if transaction is in a final completed state}	return val, exists	val, exists := t.Metadata[key]	}		return nil, false	if t.Metadata == nil {func (t *Transaction) GetMetadata(key string) (interface{}, bool) {// GetMetadata retrieves metadata value}	t.UpdatedAt = time.Now()	t.Metadata[key] = value	}		t.Metadata = make(map[string]interface{})	if t.Metadata == nil {func (t *Transaction) SetMetadata(key string, value interface{}) {// SetMetadata sets metadata with validation}	return nil		t.UpdatedAt = time.Now()	t.CustomerPhone = phone	t.CustomerName = name	t.CustomerEmail = email		}		return errors.NewValidationError("customer_email", "cannot be empty")	if email == "" {func (t *Transaction) SetCustomerInfo(email, name, phone string) error {// SetCustomerInfo sets customer information with validation}	return t.CreatedAt.After(ninetyDaysAgo)	ninetyDaysAgo := time.Now().AddDate(0, 0, -90)	// Check 90-day window		}		return false	if t.Status != StatusCompleted && t.Status != StatusPartiallyRefunded {func (t *Transaction) IsRefundable() bool {// Business Rule: Can refund within 90 days// IsRefundable checks if transaction can be refunded}	return nil	t.UpdatedAt = time.Now()		}		t.Status = StatusRefunded	} else {		t.Status = StatusPartiallyRefunded	if partial {		}		)			"can only refund completed transactions",			"invalid_refund",		return errors.NewBusinessRuleError(	if t.Status != StatusCompleted {func (t *Transaction) MarkAsRefunded(partial bool) error {// MarkAsRefunded marks transaction as refunded}	return nil	t.UpdatedAt = time.Now()	t.Status = StatusPending // Reset to pending for retry	t.RetryCount++		}		return errors.NewBusinessRuleError("max_retries_exceeded", "maximum retry attempts reached")	if !t.CanRetry() {func (t *Transaction) IncrementRetryCount() error {// IncrementRetryCount increments the retry counter}	return t.Status == StatusFailed && t.RetryCount < 3func (t *Transaction) CanRetry() bool {// Business Rule: Maximum 3 retry attempts// CanRetry checks if transaction can be retried}	return nil		t.UpdatedAt = now	t.FailedAt = &now	t.ErrorMessage = errorMessage	t.ErrorCode = errorCode	t.Status = StatusFailed	now := time.Now()		}		)			"can only fail pending or processing transactions",			"invalid_state_transition",		return errors.NewBusinessRuleError(	if t.Status != StatusProcessing && t.Status != StatusPending {func (t *Transaction) MarkAsFailed(errorCode, errorMessage string) error {// MarkAsFailed marks transaction as failed}	return nil		t.ErrorMessage = ""	t.ErrorCode = ""	t.UpdatedAt = now	t.ProcessedAt = &now	t.ProviderTransactionID = providerTransactionID	t.Status = StatusCompleted	now := time.Now()		}		return errors.NewValidationError("provider_transaction_id", "cannot be empty")	if providerTransactionID == "" {		}		)			"can only complete processing transactions",			"invalid_state_transition",		return errors.NewBusinessRuleError(	if t.Status != StatusProcessing {func (t *Transaction) MarkAsCompleted(providerTransactionID string) error {// MarkAsCompleted marks transaction as successfully completed}	return nil	t.UpdatedAt = time.Now()	t.Status = StatusProcessing		}		)			"can only process pending transactions",			"invalid_state_transition",		return errors.NewBusinessRuleError(	if t.Status != StatusPending {func (t *Transaction) MarkAsProcessing() error {// Domain logic: ensures valid state transitions// MarkAsProcessing transitions transaction to processing state}	}, nil		Metadata:       make(map[string]interface{}),		UpdatedAt:      now,		CreatedAt:      now,		RetryCount:     0,		RequestID:      uuid.New(),		CustomerEmail:  customerEmail,		Status:         StatusPending,		Provider:       provider,		PaymentMethod:  paymentMethod,		Amount:         amount,		IdempotencyKey: idempotencyKey,		PartnerID:      partnerID,		ID:             uuid.New(),	return &Transaction{		now := time.Now()		}		return nil, errors.ErrInvalidPaymentMethod	if !paymentMethod.IsValid() {		}		return nil, errors.ErrInvalidCurrency	if !amount.Currency.IsValid() {	// Validate value objects		}		return nil, errors.NewValidationError("customer_email", "cannot be empty")	if customerEmail == "" {		}		return nil, errors.NewValidationError("idempotency_key", "cannot be empty")	if idempotencyKey == "" {		}		return nil, errors.NewValidationError("partner_id", "cannot be empty")	if partnerID == uuid.Nil {	// Validate required fields	) (*Transaction, error) {	customerEmail string,	provider valueobjects.PaymentProvider,	paymentMethod valueobjects.PaymentMethod,	amount valueobjects.Money,	idempotencyKey string,	partnerID uuid.UUID,func NewTransaction(// This is a Factory Method ensuring all invariants are met// NewTransaction creates a new transaction with validation}	DeletedAt       *time.Time	FailedAt        *time.Time	ProcessedAt     *time.Time	UpdatedAt       time.Time	CreatedAt       time.Time	// Timestamps		RetryCount      int	ErrorMessage    string	ErrorCode       string	// Error handling		RequestID       uuid.UUID	UserAgent       string	IPAddress       string	// Tracking		Metadata        map[string]interface{} // Partner-specific data	Description     string	// Additional data		CustomerPhone   string	CustomerName    string	CustomerEmail   string	// Customer information		ProviderCustomerID    string	ProviderTransactionID string	// Provider details		Status          TransactionStatus	// State		Provider        valueobjects.PaymentProvider	PaymentMethod   valueobjects.PaymentMethod	Amount          valueobjects.Money	// Value Objects (immutable, validated)		IdempotencyKey  string // Prevents duplicate transactions	PartnerID       uuid.UUID	ID              uuid.UUID	// Identitytype Transaction struct {// It encapsulates all business logic related to payment processing// Transaction is the core aggregate root for payment transactions)	StatusPartiallyRefunded TransactionStatus = "partially_refunded"	StatusRefunded          TransactionStatus = "refunded"	StatusCancelled         TransactionStatus = "cancelled"	StatusFailed            TransactionStatus = "failed"	StatusCompleted         TransactionStatus = "completed"	StatusProcessing        TransactionStatus = "processing"	StatusPending           TransactionStatus = "pending"const (type TransactionStatus string// TransactionStatus represents the state of a transaction)	"Pay2Go/internal/domain/valueobjects"	"Pay2Go/internal/domain/errors"	"github.com/google/uuid"	"time"