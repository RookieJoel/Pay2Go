package valueobjects
// Package valueobjects contains immutable value objects that encapsulate
// domain concepts with validation and business logic
package valueobjects

import (
	"fmt"
	"strings"










































































































































}	return err == nil	_, err := NewCurrency(string(c))func (c Currency) IsValid() bool {// IsValid checks if currency is valid}	return string(c)func (c Currency) String() string {// String returns the string representation}	return Currency(code), nil		}		return "", errors.ErrInvalidCurrency	if !validCurrencies[code] {		}		"THB": true,		"JPY": true,		"GBP": true,		"EUR": true,		"USD": true,	validCurrencies := map[string]bool{	// Validate currency code		code = strings.ToUpper(strings.TrimSpace(code))func NewCurrency(code string) (Currency, error) {// NewCurrency validates and creates a Currency)	THB Currency = "THB"	JPY Currency = "JPY"	GBP Currency = "GBP"	EUR Currency = "EUR"	USD Currency = "USD"const (type Currency string// Currency represents a currency code (ISO 4217)}	return fmt.Sprintf("%s %.2f", m.Currency, m.Amount)func (m Money) String() string {// String returns string representation}	return m.Amount == other.Amount && m.Currency == other.Currencyfunc (m Money) Equals(other Money) bool {// Equals checks if two Money values are equal}	return m.Amount < other.Amount	}		return false	if m.Currency != other.Currency {func (m Money) IsLessThan(other Money) bool {// IsLessThan checks if m is less than other}	return m.Amount > other.Amount	}		return false	if m.Currency != other.Currency {func (m Money) IsGreaterThan(other Money) bool {// IsGreaterThan checks if m is greater than other}	}, nil		Currency: m.Currency,		Amount:   result,	return Money{		}		return Money{}, fmt.Errorf("subtraction would result in negative amount")	if result < 0 {	result := m.Amount - other.Amount		}			m.Currency, other.Currency)		return Money{}, fmt.Errorf("cannot subtract different currencies: %s and %s", 	if m.Currency != other.Currency {func (m Money) Subtract(other Money) (Money, error) {// Subtract subtracts other from m (must have same currency)}	}, nil		Currency: m.Currency,		Amount:   m.Amount + other.Amount,	return Money{		}			m.Currency, other.Currency)		return Money{}, fmt.Errorf("cannot add different currencies: %s and %s", 	if m.Currency != other.Currency {func (m Money) Add(other Money) (Money, error) {// Add adds two Money values (must have same currency)}	}, nil		Currency: curr,		Amount:   amount,	return Money{		}		return Money{}, err	if err != nil {	curr, err := NewCurrency(currency)	// Validate currency		}		return Money{}, errors.ErrAmountAboveMaximum	if amount > 100000.00 {	// Business Rule: Maximum transaction amount		}		return Money{}, errors.ErrAmountBelowMinimum	if amount < 0.01 {	// Business Rule: Minimum transaction amount		}		return Money{}, errors.NewValidationError("amount", "cannot be negative")	if amount < 0 {	// Validate amountfunc NewMoney(amount float64, currency string) (Money, error) {// NewMoney creates a new Money value object with validation}	Currency Currency	Amount   float64type Money struct {// This is a Value Object: immutable, validated, and domain-centric// Money represents a monetary amount with currency)	"Pay2Go/internal/domain/errors"